import { basename, join, relative, resolve, sep } from 'path';
import { existsSync, mkdirSync, writeFile } from 'fs';
import { EOL } from 'os';
import { promisify } from 'util';
import * as glob from 'glob';
import { SvgIconModule } from './svg-icon-module';
import { IconCollectionModule } from './icon-collection-module';

const globAsync = promisify(glob);
const writeFileAsync = promisify(writeFile);

export class SvgConverter extends IconCollectionModule {
  readonly basePath: string;
  readonly destinationPath: string;
  readonly listPath: string;

  constructor(basePath, destinationPath, listPath) {
    super([], 'icon-collection');
    this.basePath = resolve(basePath);
    this.destinationPath = resolve(destinationPath);
    this.listPath = resolve(listPath);
  }

  async convert() {
    const svgIcons = (await globAsync('**/*.svg', { cwd: this.basePath, absolute: true }))
      .map(s => new SvgIconModule(this.basePath, s))
      .sort((a, b) => a.modules.length - b.modules.length || a.rootImportPath.localeCompare(b.rootImportPath))
      .filter((v, i, a) => this._resolveDuplicates(v, i, a));
    const svgCollections = svgIcons
      .map(c => c.modules)
      .reduce((current, next) => current.concat(next.map((_, i, a) => a.slice(0, i + 1))), [] as string[][])
      .filter((v, i, a) => a.findIndex(m => m.join('/') === v.join('/')) === i)
      .map(m => new IconCollectionModule(m)
        .addModules(svgIcons.filter(i => i.modules.join('/') === m.join('/'))))
      .concat(this)
      .map((c, _, a) => this._resolveSubmodules(c, a));
    this._logModuleTree();
    this._createDirectories(svgCollections);
    const modules = [...svgCollections, ...svgIcons];
    await Promise.all(modules.map(async m => await m.createModule(this.destinationPath)));
    await this._createEntryExports(modules);
    await this._createListing();
  }

  private _resolveDuplicates(icon, index, iconArray) {
    const duplicates = iconArray.filter(m => m.kebabCaseName === icon.kebabCaseName);
    if (duplicates.length === 1) {
      return true;
    } else if (iconArray.findIndex(i => i.kebabCaseName === icon.kebabCaseName) !== index) {
      return false;
    }

    console.log(`Duplicate icon selector: ${icon.kebabCaseName}`);
    duplicates.forEach(d => console.log(` - ${relative(this.basePath, d.filePath)}`));
    console.log(` -> Resolving to ${relative(this.basePath, icon.filePath)}`);
    return true;
  }

  private _resolveSubmodules(collection, collectionArray) {
    const subModules = collectionArray.filter(
      m => collection.modules.length + 1 === m.modules.length
        && m.modules.join('/').startsWith(collection.modules.join('/')));
    return collection.addModules(subModules);
  }

  private _logModuleTree(startModule: IconCollectionModule = this, indent = 0) {
    console.log(`${' '.repeat(indent)}${startModule.pascalCaseName}`);
    startModule.childModules
      .filter(m => 'childModules' in m)
      .forEach(m => this._logModuleTree(m as IconCollectionModule, indent + 2));
  }

  private _createDirectories(modules) {
    this.destinationPath
      .split(sep)
      .map((_, i, a) => join(...a.slice(0, i + 1)))
      .concat(...modules.map(m => join(this.destinationPath, ...m.modules)))
      .filter((p, i, a) => !existsSync(p) && a.indexOf(p) === i)
      .forEach(p => {
        console.log(p);
        mkdirSync(p);
      });
  }

  private async _createEntryExports(modules) {
    const scriptPath = join(this.destinationPath, `${basename(this.destinationPath)}.ts`);
    const template = `/*
 * Don't delete this file, it's autogenerated by the ACL icons build script
 */
${modules.map(m => `export * from '${m.rootImportPath}';`).join(EOL)}
`;
    await writeFileAsync(scriptPath, template, 'utf8');
  }

  private async _createListing() {
    const scriptPath = join(this.listPath, `svg-icon-collection.ts`);
    const iconComponentsDetails = this.iconComponentDetails();
    const detailsTemplate = (details: { selector: string, name: string, modules: string[] }) => `  {
    selector: '${details.selector}',
    name: '${details.name}',
    modules: [${details.modules.map(t => `'${t}'`).join(', ')}],
    component: ${details.name},
  },`;
    const template = `/*
 * Don't delete this file, it's autogenerated by the ACL icons build script
 */
import {
${iconComponentsDetails.map(d => `  ${d.name},`).join(EOL)}
} from 'sbb-angular';

export const iconComponentDetails = [
${iconComponentsDetails.map(d => detailsTemplate(d)).join(EOL)}
];

export const iconComponentList = [
${iconComponentsDetails.map(d => `  ${d.name},`).join(EOL)}
];
`;
    await writeFileAsync(scriptPath, template, 'utf8');
  }
}
