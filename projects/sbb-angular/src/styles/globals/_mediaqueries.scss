// ----------------------------------------------------------------------------------------------------
// Mediaqueries
// ----------------------------------------------------------------------------------------------------

@import 'variables';
@import 'functions';

/**
 * Inspired from https://github.com/guardian/sass-mq.git
 */

/**
 * // To enable support for browsers that do not support @media queries,
 * (IE <= 8, Firefox <= 3, Opera <= 9) set $mq-responsive to false
 * Create a separate stylesheet served exclusively to these browsers,
 * meaning @media queries will be rasterized, relying on the cascade itself
 */
$mq-responsive: true;

/**
 * Name your breakpoints in a way that creates a ubiquitous language
 * across team members. It will improve communication between
 * stakeholders, designers, developers, and testers.
 */
$mq-breakpoints: (
	mobilePortrait: $size-breakpoint-mobile-portrait,
	mobileLandscape: $size-breakpoint-mobile-landscape,
	tabletPortrait: $size-breakpoint-tablet-portrait,
	tabletLandscape: $size-breakpoint-tablet-landscape,
	desktop: $size-breakpoint-desktop,	
	desktopLarge: $size-breakpoint-desktop-large,
	desktopLargePlus: $size-breakpoint-desktop-large-plus,
	desktopMaxWidth: $size-breakpoint-desktop-max-width,
	desktop4k: $size-breakpoint-desktop-4k,
	desktop5k: $size-breakpoint-desktop-5k
);

/**
 * Define the breakpoint from the $mq-breakpoints list that should
 * be used as the target width when outputting a static stylesheet
 * (i.e. when $mq-responsive is set to 'false').
 */
$mq-static-breakpoint: mobile-landscape;

/**
 * If you want to display the currently active breakpoint in the top
 * right corner of your site during development, add the breakpoints
 * to this list, ordered by width, e.g. (mobile, tablet, desktop).
 */
$mq-show-breakpoints: (mobile-landscape, tablet-portrait, tablet-landscape, desktop, desktop-plus, desktop-4k, desktop-5k);


@function mq-get-breakpoint-width($name) {
	@if(map-has-key($mq-breakpoints, $name)) {
		@return map-get($mq-breakpoints, $name);
	} @else {
		@warn "Breakpoint #{$name} does not exist";
	}
}

/**
 * Media Query mixin
 * Usage:
 * .element {
 *     @include mq($from: mobile) {
 *         color: red;
 *     }
 *     @include mq($to: tablet) {
 *         color: blue;
 *     }
 *     @include mq(mobile, tablet) {
 *         color: green;
 *     }
 *     @include mq($from: tablet, $and: '(orientation: landscape)') {
 *         color: teal;
 *     }
 *     @include mq(950px) {
 *         color: hotpink;
 *     }
 * }
 */

@mixin mq($from: false, $to: false, $and: false, $height: false) {

	// Initialize variables
	$min-size: 0;
	$max-size: 0;
	$media-query: '';
	$axis: if($height, 'height', 'width');

	// From: this breakpoint (inclusive)
	@if $from {
		@if type-of($from) == number {
			$min-size: px-to-em($from, 16);
		} @else {
			$min-size: px-to-em(mq-get-breakpoint-width($from), 16);
		}
	}

	// To: that breakpoint (exclusive)
	@if $to {
		@if type-of($to) == number {
			$max-size: px-to-em($to, 16) - .01em;
		} @else {
			$max-size: px-to-em(mq-get-breakpoint-width($to), 16) - .01em;
		}
	}

	// Responsive support is disabled, rasterize the output outside @media blocks
	// The browser will rely on the cascade itself.
	@if ($mq-responsive == false) {
		$static-breakpoint-width: mq-get-breakpoint-width($mq-static-breakpoint);
		@if type-of($static-breakpoint-width) == number {
			$target-width: px-to-em($static-breakpoint-width, 16);
			// Output only rules that start at or span our target width
			@if ($and == false and ($min-size <= $target-width) and (($to == false) or ($max-size >= $target-width))) {
				@content;
			}
		} @else {
			// Throw a warning if $mq-static-breakpoint is not in the $mq-breakpoints list
			@warn "No static styles will be output: #{$static-breakpoint-width}";
		}
	}

		// Responsive support is enabled, output rules inside @media queries
	@else {
		@if $min-size != 0 { $media-query: '#{$media-query} and (min-#{$axis}: #{$min-size})'; }
		@if $max-size != 0 { $media-query: '#{$media-query} and (max-#{$axis}: #{$max-size})'; }
		@if $and { $media-query: '#{$media-query} and #{$and}'; }

		$media-query: unquote(#{$media-query});

		@media #{all + $media-query} {
			@content;
		}
	}
}

/**
 * Add a breakpoint
 * Usage: $mq-breakpoints: mqAddBreakpoint(tvscreen, 1920px);
 */
@function mq-add-breakpoint($name, $breakpoint) {
	$new-breakpoint: ($name: $breakpoint);
	@return map-merge($mq-breakpoints, $new-breakpoint);
}

/**
 * Create JSON string of map of breakpoints
 */
@function mq-get-breakpoints-json($breakpoints: $mq-breakpoints) {
	$JSON: '';

	@each $name in map-keys($breakpoints) {
		$value: map-get($breakpoints, $name);

		$JSON: $JSON + '\\"#{$name}\\"\\:\\"#{$value}\\"\\,';
	}

	// Remove last "\,"
	$JSON: str-slice($JSON, 1, str-length($JSON) - 2);

	@return \{#{$JSON}\};
}


/**
 * Create JSON string of single breakpoint
 */
@function mq-get-breakpoint-json($name, $value) {
	@return \{\"name\"\:\"#{$name}\"\,\"value\"\:\"#{$value}\"\};
}
